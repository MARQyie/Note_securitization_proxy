# --------------------------------------------
# TABLES CFA
# Mark van der Plaat
# December 2021
# --------------------------------------------
''' This script makes tables for the CFA securitization paper.

    All data is generated by Lavaan in R. See CFA_v1.R for more details.
'''

# --------------------------------------------
# Import Packages
# --------------------------------------------

# Data manipulation
import pandas as pd
import numpy as np
from scipy import stats

# Plotting
import matplotlib.pyplot as plt
import seaborn as sns

sns.set(style='whitegrid', font_scale=3)

import os

os.chdir(r'D:\RUG\PhD\Materials_papers\01-Note_on_securitization')


# --------------------------------------------
# Functions
# --------------------------------------------
# Set heatmap function 
def heatmap(matrix, file, annot=True):
    # Set mask
    mask = np.triu(np.ones_like(matrix, dtype=bool), 1)

    # Set aesthetics
    dic_aes = {'mask': mask,
               'annot': annot,
               'center': 0,
               'cmap': 'coolwarm',
               'fmt': '.3f'}

    # Make heatmap
    fig, ax = plt.subplots(figsize=(36, 24))
    sns.heatmap(matrix, **dic_aes)
    plt.tight_layout()

    # Save heatmap
    fig.savefig('Figures/CFA_covariance_maps/' + file)


# Function to make the parameter estimate table pretty
def tidyParamEst(data):
    # Select columns
    data_clean = data.iloc[:, [3, 4, 6, 10]]

    # Set column names
    data_clean.columns = ['Estimates', 'SD', 'P-value', 'Estimates (compl. std.)']

    # Set index names
    ## Prelims
    index_lst = list()
    lst_factors = ('SEC', 'ABCP', 'ABSCDO')
    factor_labels = ('F3', 'F2', 'F1')
    factor_dict = dict(zip(lst_factors, factor_labels))

    var_names = ['cr_as_sbo', 'cr_as_rmbs',
                 'cr_as_abs', 'hmda_sec_amount',
                 'cr_secveh_ta',
                 'cr_sec_income', 'cr_serv_fees',
                 'cr_cds_purchased', 'cr_abcp_ta',
                 'cr_abcp_uc_own', 'cr_abcp_ce_own',
                 'cr_abcp_uc_oth', 'cr_abcp_ce_oth']
    var_labels = ['Small Bus. Obl. Transf.', 'Sec. Residential Loans',
                  'Sec. Other Assets', 'Sec. Residential Mortgages',
                  'TA Sec. Vehicles',
                  'Sec. Income', 'Servicing Fees',
                  'CDSs Purchased', 'TA ABCP Conduits',
                  'Un. Com. Own ABCP Conduits',
                  'Credit Exp. Own ABCP Conduits', 'Un. Com. Other ABCP Conduits']
    var_dict = dict(zip(var_names, var_labels))

    ## Loop over rows to get the correct parameter name
    for index, row in data.iloc[:, :3].iterrows():
        if row['lhs'] in lst_factors:
            if row['rhs'] in lst_factors:
                if row['lhs'] == row['rhs']:
                    index_lst.append(['Variance ($\phi$)', str(factor_dict[row['lhs']]), np.nan])
                else:
                    index_lst.append(
                        ['Covariance ($\phi$)', str(factor_dict[row['lhs']]), str(factor_dict[row['rhs']])])
                # index_lst.append('$\phi_{' + str(row['lhs']) + ',' +  str(row['rhs']) +'}$')
            else:
                index_lst.append(['Loading ($\lambda$)', str(factor_dict[row['lhs']]), str(var_dict[row['rhs']])])
                # index_lst.append('$\lambda_{' + str(row['lhs']) + ',' +  str(var_dict[row['rhs']]) +'}$')
        else:
            if row['lhs'] == row['rhs']:
                index_lst.append(['Variance ($\delta$)', str(var_dict[row['lhs']]), np.nan])
            else:
                index_lst.append(['Covariance ($\delta$)', str(var_dict[row['lhs']]), str(var_dict[row['rhs']])])
            # index_lst.append('$\delta_{' + str(var_dict[row['lhs']]) + ',' +  str(var_dict[row['rhs']]) +'}$')

    ## Change Index
    data_index = list(map(list, zip(*index_lst)))
    data_clean = data_clean.assign(LHS=data_index[1],
                                   RHS=data_index[2])

    data_clean.set_index(['LHS', 'RHS'], inplace=True)

    return data_clean


# Function to make latex table from pandas dataframe
def table2Latex(data, options, notes, string_size):
    # Get latex table
    latex_table = data.to_latex(na_rep='', float_format='{:0.4f}'.format,
                                longtable=False, multicolumn=False,
                                multicolumn_format='c', escape=False,
                                **options)

    # add notes to bottom of the table
    location_mid = latex_table.find('\end{tabular}')
    latex_table = latex_table[:location_mid] + notes + latex_table[location_mid:]

    # adjust sting size
    location_size = latex_table.find('\centering\n')
    latex_table = latex_table[:location_size + len('\centering\n')] + string_size + latex_table[location_size + len(
        '\centering\n'):]

    # Insert multicolumns for the fit measures
    if data.index[0] == 'No. Params':
        # Absolute fit
        abs_fit = '& \\\\ \n \\multicolumn{2}{l}{\\textbf{Absolute fit}} \\\\ \n'
        location = latex_table.find('SRMR')
        latex_table = latex_table[:location] + abs_fit + latex_table[location:]

        # Parsimonious fit
        pars_fit = '& \\\\ \n \\multicolumn{2}{l}{\\textbf{Parsimonious fit}} \\\\ \n'
        location = latex_table.find('RMSEA')
        latex_table = latex_table[:location] + pars_fit + latex_table[location:]

        # Comparative and relative fit
        cr_fit = '& \\\\ \n \\multicolumn{2}{l}{\\textbf{Comparative and relative fit}} \\\\ \n'
        location = latex_table.find('Yuan--Bentler $\chi^2$')
        latex_table = latex_table[:location] + cr_fit + latex_table[location:]

        # Other
        oth_fit = '& \\\\ \n \\multicolumn{2}{l}{\\textbf{Other}} \\\\ \n'
        location = latex_table.find('AIC')
        latex_table = latex_table[:location] + oth_fit + latex_table[location:]

    # Insert multicolumns for the parameter estimates for two-factor model
    if (data.index[0][0] == 'F1') and (data.index[-1][0] != 'F3'):
        # Factor loadings
        factor_loadings = ' \n \\multicolumn{6}{l}{\\textbf{Factor loadings}} \\\\ \n'
        location = latex_table.find('F1')
        latex_table = latex_table[:location] + factor_loadings + latex_table[location:]

        # Error covariances (unique covariances)
        error_cov = '&&&&& \\\\ \n \\multicolumn{6}{l}{\\textbf{Error covariances}} \\\\ \n'
        location = latex_table.find('Un. Com. Own ABCP Conduits & Un. Com. Other ABCP Conduits')
        latex_table = latex_table[:location] + error_cov + latex_table[location:]

        # Unique variances
        unique_var = '\n&&&&& \\\\ \n \\multicolumn{6}{l}{\\textbf{Unique variances}} \\\\'
        location = latex_table.find('\nSmall Bus. Obl. Transf. &')
        latex_table = latex_table[:location] + unique_var + latex_table[location:]

        # Factor variances
        fac_var = '&&&&& \\\\ \n \\multicolumn{6}{l}{\\textbf{Factor variances}} \\\\ \n'
        location = latex_table.replace('F1', 'XX', 1).find('F1')  # trick to find the second ABSCDO
        latex_table = latex_table[:location] + fac_var + latex_table[location:]

        # Factor covariances
        fac_cov = '&&&&& \\\\ \n \\multicolumn{6}{l}{\\textbf{Factor covariances}} \\\\ \n'
        location = latex_table.find('F1 & F2')
        latex_table = latex_table[:location] + fac_cov + latex_table[location:]

    # Insert multicolumns for the parameter estimates for one-factor model
    if data.index[-1][0] == 'F3':
        # Factor loadings
        factor_loadings = ' \n \\multicolumn{6}{l}{\\textbf{Factor loadings}} \\\\ \n'
        location = latex_table.find('F1')
        latex_table = latex_table[:location] + factor_loadings + latex_table[location:]

        # Error covariances (unique covariances)
        error_cov = '&&&&& \\\\ \n \\multicolumn{6}{l}{\\textbf{Error covariances}} \\\\ \n'
        location = latex_table.find('\nUn. Com. Own ABCP Conduits & Un. Com. Other ABCP Conduits')
        latex_table = latex_table[:location] + error_cov + latex_table[location:]

        # Unique variances
        unique_var = '\n&&&&& \\\\ \n \\multicolumn{6}{l}{\\textbf{Unique variances}} \\\\'
        location = latex_table.find('\nSmall Bus. Obl. Transf. &')
        latex_table = latex_table[:location] + unique_var + latex_table[location:]

        # Factor variances
        fac_var = '&&&&& \\\\ \n \\multicolumn{6}{l}{\\textbf{Factor variances}} \\\\ \n'
        location = latex_table.replace('F1', 'XX', 2).find('F1')
        latex_table = latex_table[:location] + fac_var + latex_table[location:]

        # Insert multi columns in the communality table
    if data.columns[-1] == 'Source':
        # ABS sec
        col = ' \\multicolumn{4}{l}{\\textbf{Loading only on F1}} \\\\ \n'
        location = latex_table.find('Small Bus. Obl. Transf.')
        latex_table = latex_table[:location] + col + latex_table[location:]

        # Both factors
        col = '&&&\\\\ \n \\multicolumn{4}{l}{\\textbf{Loading on both F1 and F2}} \\\\ \n'
        location = latex_table.find('Sec. Income')
        latex_table = latex_table[:location] + col + latex_table[location:]

        # ABCP factors
        col = '&&&\\\\ \n \\multicolumn{4}{l}{\\textbf{Loading only on F2}} \\\\ \n'
        location = latex_table.find('TA ABCP Conduits')
        latex_table = latex_table[:location] + col + latex_table[location:]

    return latex_table


def tidyFitInd(data):
    # Get indices
    lst_fi = ['npar', 'df', 'baseline.df', 'srmr', 'rmsea.robust',
              'rni.robust', 'chisq.scaled', 'pvalue.scaled',
              'cfi.robust', 'tli.robust', 'aic', 'bic']

    data_clean = data.loc[lst_fi, :]

    # Rename index
    lst_fi_labels = ['No. Params', 'DoF', 'DoF baseline', 'SRMR', 'RMSEA',
                     'RNI', 'Yuan--Bentler $\chi^2$',
                     'p-val Yuan--Bentler $\chi^2$',
                     'CFI', 'TLI',
                     'AIC', 'BIC']
    data_clean.index = lst_fi_labels

    # Rename columns
    if data.shape[1] == 3:
        data_clean.columns = ['EFA', 'Theory', 'Combined']
    if data.shape[1] == 2:
        data_clean.columns = ['(1)', '(2)']
    else:
        data_clean.rename(columns={'Unnamed: 1': 'Index'}, inplace=True)

    # Format values
    data_clean = data_clean.applymap(lambda x: '{:,.4f}'.format(x) if not 24 <= x <= 66 else '{:,.0f}'.format(x))

    return data_clean


# Function to make the modification table table pretty
def tidyModInd(data):
    # Select columns
    data_clean = data.iloc[:, [3, 4, 6]]

    # Set column names
    data_clean.columns = ['Mod. Indices', 'EPC', 'EPC (compl. std.)']

    # Set index names
    ## Prelims
    index_lst = list()
    lst_factors = ('SEC', 'ABCP', 'ABSCDO')
    factor_labels = ('F3', 'F2', 'F1')
    factor_dict = dict(zip(lst_factors, factor_labels))

    var_names = ['cr_as_sbo', 'cr_as_rmbs',
                 'cr_as_abs', 'hmda_sec_amount',
                 'cr_secveh_ta',
                 'cr_sec_income', 'cr_serv_fees',
                 'cr_cds_purchased', 'cr_abcp_ta',
                 'cr_abcp_uc_own', 'cr_abcp_ce_own',
                 'cr_abcp_uc_oth', 'cr_abcp_ce_oth']
    var_labels = ['Small Bus. Obl. Transf.', 'Sec. Residential Loans',
                  'Sec. Other Assets', 'Sec. Residential Mortgages',
                  'TA Sec. Vehicles',
                  'Sec. Income', 'Servicing Fees',
                  'CDSs Purchased', 'TA ABCP Conduits',
                  'Un. Com. Own ABCP Conduits',
                  'Credit Exp. Own ABCP Conduits', 'Un. Com. Other ABCP Conduits']
    var_dict = dict(zip(var_names, var_labels))

    ## Loop over rows to get the correct parameter name
    for index, row in data.iloc[:, :3].iterrows():
        if row['lhs'] in lst_factors:
            if row['rhs'] in lst_factors:
                if row['lhs'] == row['rhs']:
                    index_lst.append(['Variance ($\phi$)', str(factor_dict[row['lhs']]), np.nan])
                else:
                    index_lst.append(['Covariance', str(factor_dict[row['lhs']]), str(row['rhs'])])
                # index_lst.append('$\phi_{' + str(row['lhs']) + ',' +  str(row['rhs']) +'}$')
            else:
                index_lst.append(['Loading', str(factor_dict[row['lhs']]), str(var_dict[row['rhs']])])
                # index_lst.append('$\lambda_{' + str(row['lhs']) + ',' +  str(var_dict[row['rhs']]) +'}$')
        else:
            if row['lhs'] == row['rhs']:
                index_lst.append(['Variance ($\delta$)', str(var_dict[row['lhs']]), np.nan])
            else:
                index_lst.append(['Covariance', str(var_dict[row['lhs']]), str(var_dict[row['rhs']])])
            # index_lst.append('$\delta_{' + str(var_dict[row['lhs']]) + ',' +  str(var_dict[row['rhs']]) +'}$')

    ## Change Index
    data_index = list(map(list, zip(*index_lst)))
    data_clean = data_clean.assign(Operator=data_index[0],
                                   LHS=data_index[1],
                                   RHS=data_index[2])

    data_clean.set_index(['Operator', 'LHS', 'RHS'], inplace=True)

    return data_clean


# --------------------------------------------
# Prelims
# --------------------------------------------
var_names = ['cr_as_sbo', 'cr_as_rmbs',
             'cr_as_abs', 'hmda_sec_amount',
             'cr_secveh_ta',
             'cr_sec_income', 'cr_serv_fees',
             'cr_cds_purchased', 'cr_abcp_ta',
             'cr_abcp_uc_own', 'cr_abcp_ce_own',
             'cr_abcp_uc_oth', 'cr_abcp_ce_oth']
var_labels = ['Small Bus. Obl. Transf.', 'Sec. Residential Loans',
              'Sec. Other Assets', 'Sec. Residential Mortgages',
              'TA Sec. Vehicles',
              'Sec. Income', 'Servicing Fees',
              'CDSs Purchased', 'TA ABCP Conduits',
              'Un. Com. Own ABCP Conduits',
              'Credit Exp. Own ABCP Conduits', 'Un. Com. Other ABCP Conduits']
dict_vars = dict(zip(var_names, var_labels))

# Add Factor names
dict_vars.update({'LS': 'Loan Sales',
                  'ABS': 'ABS Sec.',
                  'CDO': 'CDO Sec.',
                  'ABCP': 'ABCP Sec.',
                  'SEC': 'Securitization'})

# --------------------------------------------
# Load data 
# --------------------------------------------

# fit indices 
df_fi_onesec = pd.read_csv('Results/CFA_fitmeasures_onesec.csv', index_col=0)

df_fi_efa = pd.read_csv('Results/CFA_fitmeasures_efa.csv', index_col=0)
df_fi_theory = pd.read_csv('Results/CFA_fitmeasures_theory.csv', index_col=0)
df_fi_combined = pd.read_csv('Results/CFA_fitmeasures_combined.csv', index_col=0)

df_fi_higherorder = pd.read_csv('Results/CFA_fitmeasures_higherorder.csv', index_col=0)
df_fi_higherorder_alt = pd.read_csv('Results/CFA_fitmeasures_higherorder_alt.csv', index_col=0)

# Parameter estimates
df_params_onesec = pd.read_csv('Results/CFA_params_onesec.csv', index_col=0)

df_params_efa = pd.read_csv('Results/CFA_params_efa.csv', index_col=0)
df_params_theory = pd.read_csv('Results/CFA_params_theory.csv', index_col=0)
df_params_combined = pd.read_csv('Results/CFA_params_combined.csv', index_col=0)

df_params_higherorder = pd.read_csv('Results/CFA_params_higherorder.csv', index_col=0)
df_params_higherorder_alt = pd.read_csv('Results/CFA_params_higherorder_alt.csv', index_col=0)

# Reliability measures
df_reliability_efa = pd.read_csv('Results/CFA_reliability_efa.csv', index_col=0)
df_reliability_theory = pd.read_csv('Results/CFA_reliability_theory.csv', index_col=0)
df_reliability_combined = pd.read_csv('Results/CFA_reliability_combined.csv', index_col=0)

# NOTE: We only get the results from the good-fitting models from this point onward
# Modification indices
df_mi_theory = pd.read_csv('Results/CFA_modindices_theory.csv', index_col=0)

# Model implied covariance matrix
df_micm_theory = pd.read_csv('Results/CFA_modimplied_cov_theory.csv', index_col=0)

# Residual covariance matrix
df_rcm_theory = pd.read_csv('Results/CFA_rescov_theory.csv', index_col=0)
df_srcm_theory = pd.read_csv('Results/CFA_rescov_standard_theory.csv', index_col=0)

# Communalities
df_r2_theory = pd.read_csv('Results/CFA_r2_theory.csv', index_col=0)

# --------------------------------------------
# fit indices 
# --------------------------------------------

# One securization factor
## Get tidy table
df_fi_onesec_tidy = tidyFitInd(df_fi_onesec)

## To latex
### Prelims
dict_options = {'column_format': 'p{3cm}' + 'p{1.5cm}' * df_fi_onesec_tidy.shape[1],
                'caption': ('Fit Indices: One Securitization Factor Model'),
                'label': 'tab:cfa_fit_onesec',
                'position': 'th'}
notes = '\\multicolumn{2}{p{4.5cm}}{\\textit{Notes.} Fit indices of the model with one securitization factor.} \n'
string_size = '\\scriptsize\n'

### Get latex table and save
latex_fi_onesec = table2Latex(df_fi_onesec_tidy, dict_options, notes, string_size)
text_latex_fi_onesec = open('Results/CFA_fi_onesec.tex', 'w')
text_latex_fi_onesec.write(latex_fi_onesec)
text_latex_fi_onesec.close()

# All two factor models
## Get tidy table
df_fi_2f = pd.concat([df_fi_efa, df_fi_theory, df_fi_combined], axis=1)
df_fi_2f_tidy = tidyFitInd(df_fi_2f)

## To latex
### Prelims
dict_options = {'column_format': 'p{3cm}' + 'p{1.5cm}' * df_fi_2f_tidy.shape[1],
                'caption': ('Fit Indices: Two-factor Models'),
                'label': 'tab:cfa_fit_twofactor_models',
                'position': 'th'}
notes = '\\multicolumn{4}{p{9cm}}{\\textit{Notes.} Fit indices of the two-factor models. The first column contains the fit indices for the model based on the exploratory factor analysis (EFA), and the second column the model based on Table \\ref{tab:possible_proxies}. The last column presents the fit indices for the model where we combine exploratory factor analysis and Table \\ref{tab:possible_proxies}.} \n'
string_size = '\\scriptsize\n'

### Get latex table and save
latex_fi_2f = table2Latex(df_fi_2f_tidy, dict_options, notes, string_size)
text_latex_latex_fi_2f = open('Results/CFA_fi_2f.tex', 'w')
text_latex_latex_fi_2f.write(latex_fi_2f)
text_latex_latex_fi_2f.close()

# Three factor models
## Get tidy table
# df_fi_3f = pd.concat([df_fi_higherorder, df_fi_higherorder_alt], axis = 1)
df_fi_3f_tidy = tidyFitInd(df_fi_higherorder_alt)

## To latex
### Prelims
dict_options = {'column_format': 'p{3cm}' + 'p{1.5cm}' * df_fi_3f_tidy.shape[1],
                'caption': ('Fit Indices: Three-factor Model'),
                'label': 'tab:cfa_fit_threefactor_models',
                'position': 'th'}
notes = '\\multicolumn{2}{p{5cm}}{\\textit{Notes.} it indices of the three-factor model, where the proxies that load on both factors in the combined two-factor model load on the higher-order column.} \n'
string_size = '\\scriptsize\n'

### Get latex table and save
latex_fi_3f = table2Latex(df_fi_3f_tidy, dict_options, notes, string_size)
text_latex_latex_fi_3f = open('Results/CFA_fi_3f.tex', 'w')
text_latex_latex_fi_3f.write(latex_fi_3f)
text_latex_latex_fi_3f.close()

# --------------------------------------------
# Parameter estimates 
# --------------------------------------------

# One securitization factor
## Get tidy table
df_params_onesec_tidy = tidyParamEst(df_params_onesec)

## To latex
### Prelims
dict_options = {'column_format': 'p{4.75cm}p{4.75cm}' + 'p{1cm}' * df_params_onesec_tidy.shape[1],
                'caption': ('Factor Loadings, Variances and Covariances: One Securitization Factor Model'),
                'label': 'tab:cfa_table_onesec',
                'position': 'th'}
notes = '\\multicolumn{6}{p{16cm}}{\\textit{Notes.} Factor loadings, factor variances and covariances, and unique variances and covariances of the factor model with one factor. The last column presents the completely standardized estimates, where the factor variances are fixed to one and all other parameters are standardized.} \n'
string_size = '\\scriptsize\n'

### Get latex table and save
latex_params_onesec = table2Latex(df_params_onesec_tidy, dict_options, notes, string_size)
text_latex_params_onesec = open('Results/CFA_params_onesec.tex', 'w')
text_latex_params_onesec.write(latex_params_onesec)
text_latex_params_onesec.close()

# Two factors: EFA
## Get tidy table
df_params_efa_tidy = tidyParamEst(df_params_efa)

## To latex
### Prelims
dict_options = {'column_format': 'p{4.75cm}p{4.75cm}' + 'p{1cm}' * df_params_efa_tidy.shape[1],
                'caption': ('Factor Loadings, Variances and Covariances: Two-factor EFA Model'),
                'label': 'tab:cfa_table_2fefa',
                'position': 'th'}
notes = '\\multicolumn{6}{p{16cm}}{\\textit{Notes.} Factor loadings, factor variances and covariances, and unique variances and covariances of the two-factor model based on the exploratory factor analysis (EFA). The last column presents the completely standardized estimates, where the factor variances are fixed to one and all other parameters are standardized.} \n'
string_size = '\\scriptsize\n'

### Get latex table and save
latex_params_efa = table2Latex(df_params_efa_tidy, dict_options, notes, string_size)
text_latex_params_onesec = open('Results/CFA_params_efa.tex', 'w')
text_latex_params_onesec.write(latex_params_efa)
text_latex_params_onesec.close()

# Two factors: Theory
df_params_theory_tidy = tidyParamEst(df_params_theory)

## To latex
### Prelims
dict_options = {'column_format': 'p{4.75cm}p{4.75cm}' + 'p{1cm}' * df_params_theory_tidy.shape[1],
                'caption': ('Factor Loadings, Variances and Covariances: Two-factor Theory Model'),
                'label': 'tab:cfa_table_2ftheory',
                'position': 'th'}
notes = '\\multicolumn{6}{p{16cm}}{\\textit{Notes.} Factor loadings, factor variances and covariances, and unique variances and covariances of the two-factor model based on Table \\ref{tab:possible_proxies}. The last column presents the completely standardized estimates, where the factor variances are fixed to one and all other parameters are standardized.} \n'
string_size = '\\scriptsize\n'

### Get latex table and save
latex_params_theory = table2Latex(df_params_theory_tidy, dict_options, notes, string_size)
text_latex_params_theory = open('Results/CFA_params_theory.tex', 'w')
text_latex_params_theory.write(latex_params_theory)
text_latex_params_theory.close()

# Two factors: Combined
df_params_combined_tidy = tidyParamEst(df_params_combined)

## To latex
### Prelims
dict_options = {'column_format': 'p{4.75cm}p{4.75cm}' + 'p{1cm}' * df_params_combined_tidy.shape[1],
                'caption': ('Factor Loadings, Variances and Covariances: Two-factor Combined Model'),
                'label': 'tab:cfa_table_2fcombined',
                'position': 'th'}
notes = '\\multicolumn{6}{p{16cm}}{\\textit{Notes.} Factor loadings, factor variances and covariances, and unique variances and covariances of the two-factor model based on the exploratory factor analysis (EFA) and Table \\ref{tab:possible_proxies}. The last column presents the completely standardized estimates, where the factor variances are fixed to one and all other parameters are standardized.} \n'
string_size = '\\scriptsize\n'

### Get latex table and save
latex_params_combined = table2Latex(df_params_combined_tidy, dict_options, notes, string_size)
text_latex_params_combined = open('Results/CFA_params_combined.tex', 'w')
text_latex_params_combined.write(latex_params_combined)
text_latex_params_combined.close()

# Three factors
df_params_higherorder_tidy = tidyParamEst(df_params_higherorder)

## To latex
### Prelims
dict_options = {'column_format': 'p{4.75cm}p{4.75cm}' + 'p{1cm}' * df_params_higherorder_tidy.shape[1],
                'caption': ('Factor Loadings, Variances and Covariances: Three-factor Model'),
                'label': 'tab:cfa_table_3f',
                'position': 'th'}
notes = '\\multicolumn{6}{p{16cm}}{\\textit{Notes.} Factor loadings, factor variances and covariances, and unique variances and covariances of the three-factor model based on the combined two-factor model . The last column presents the completely standardized estimates, where the factor variances are fixed to one and all other parameters are standardized.} \n'
string_size = '\\scriptsize\n'

### Get latex table and save
latex_params_higherorder = table2Latex(df_params_higherorder_tidy, dict_options, notes, string_size)
text_latex_params_higherorder = open('Results/CFA_params_higherorder.tex', 'w')
text_latex_params_higherorder.write(latex_params_higherorder)
text_latex_params_higherorder.close()

# Three factors: alternative
df_params_higherorder_alt_tidy = tidyParamEst(df_params_higherorder_alt)

## To latex
### Prelims
dict_options = {'column_format': 'p{4.75cm}p{4.75cm}' + 'p{1cm}' * df_params_higherorder_alt_tidy.shape[1],
                'caption': ('Factor Loadings, Variances and Covariances: Three-factor Model'),
                'label': 'tab:cfa_table_3falt',
                'position': 'th'}
notes = '\\multicolumn{6}{p{16cm}}{\\textit{Notes.} Factor loadings, factor variances and covariances, and unique variances and covariances of the three-factor model with alternative specification based on the combined two-factor model. The last column presents the completely standardized estimates, where the factor variances are fixed to one and all other parameters are standardized.} \n'
string_size = '\\scriptsize\n'

### Get latex table and save
latex_params_higherorder_alt = table2Latex(df_params_higherorder_alt_tidy, dict_options, notes, string_size)
text_latex_params_higherorder_alt = open('Results/CFA_params_higherorder_alt.tex', 'w')
text_latex_params_higherorder_alt.write(latex_params_higherorder_alt)
text_latex_params_higherorder_alt.close()

# --------------------------------------------
#  Reliability
# --------------------------------------------

# Two-factor models
df_reliability = pd.concat([df_reliability_efa.loc['omega', :], \
                            df_reliability_theory.loc['omega', :], \
                            df_reliability_combined.loc['omega', :]], axis=1)

df_reliability.columns = ['EFA', 'Theory', 'Combined']
df_reliability.index = ['F1', 'F2']

## To latex
### Prelims
dict_options = {'column_format': 'p{4cm}' + 'p{1cm}' * df_reliability.T.shape[1],
                'caption': ('Scale Reliability Two-factor models'),
                'label': 'tab:cfa_reliability_2f',
                'position': 'th'}
notes = '\\multicolumn{3}{p{6cm}}{\\textit{Notes.} Scale reliability for all two-factor models. } \n'
string_size = '\\scriptsize\n'

### Get latex table and save
latex_params_reliability = table2Latex(df_reliability.T, dict_options, notes, string_size)
text_latex_params_reliability = open('Results/CFA_scale_reliability_2f.tex', 'w')
text_latex_params_reliability.write(latex_params_reliability)
text_latex_params_reliability.close()

# --------------------------------------------
#  Model implied covariance matrix 
# --------------------------------------------

# Theory model
heatmap(df_micm_theory.rename(columns=dict_vars, index=dict_vars), 'Modelimplied_cov_heatmap_theory.png')

# --------------------------------------------
# Residual covariance matrix
# --------------------------------------------

# Theory model
heatmap(df_rcm_theory.rename(columns=dict_vars, index=dict_vars), 'Residual_cov_heatmap_theory.png')
heatmap(df_srcm_theory.rename(columns=dict_vars, index=dict_vars), 'Residual_cov_std_heatmap_theory.png')

# --------------------------------------------
# Modification indices 
# --------------------------------------------

# Theory
## Get tidy table
df_mi_theory_tidy = tidyModInd(df_mi_theory)

## To latex
### Prelims
dict_options = {'column_format': 'p{2cm}p{4.75cm}p{4.75cm}' + 'p{1cm}' * df_mi_theory_tidy.shape[1],
                'caption': ('Modification Indices: Two-factor Theory Model'),
                'label': 'tab:cfa_mi_theory',
                'position': 'th'}
notes = '\\multicolumn{6}{p{17cm}}{\\textit{Notes.} Modification indices of the two-factor theory model. The last column presents the completely standardized modification indices, where the factor variances are fixed to one and all other parameters are standardized.} \n'
string_size = '\\scriptsize\n'

### Get latex table and save
latex_mi_theory = table2Latex(df_mi_theory_tidy, dict_options, notes, string_size)
text_latex_mi_theory = open('Results/CFA_mi_theory.tex', 'w')
text_latex_mi_theory.write(latex_mi_theory)
text_latex_mi_theory.close()

# --------------------------------------------
# Communalities
# --------------------------------------------

# Theory model
## Clean the table
df_r2_theory_tidy = df_r2_theory.rename(columns={'x': 'Communality'}, index=dict_vars)

## Add unique variance column
df_r2_theory_tidy['Unique Variance'] = 1 - df_r2_theory_tidy.Communality

## Add column whether variable is new, used by or based on
df_r2_theory_tidy['Source'] = ['Used by', 'Used by', 'From Call Reports', 'Used by', 'Based on',
                               'Used by', 'From Call Reports', 'From Call Reports', 'Used by', 'Used by',
                               'Based on', 'Based on']

## To latex
### Prelims
dict_options = {'column_format': 'p{5cm}' + 'p{1.5cm}' * (df_r2_theory_tidy.shape[1] - 1) + 'p{2.5cm}',
                'caption': ('Communalities and Unique Variances: Two-factor Theory Model'),
                'label': 'tab:cfa_r2_theory',
                'position': 'th'}
notes = '\\multicolumn{4}{p{11.5cm}}{\\textit{Notes.} Communalities and unique variancess of the proxy variables. The last column indicates whether the proxy is directly from the Call Reports, used by the literature or based on the literature, see Table \\ref{tab:possible_proxies}.} \n'
string_size = '\\scriptsize\n'

### Get latex table and save
latex_r2_theory = table2Latex(df_r2_theory_tidy, dict_options, notes, string_size)
text_latex_r2_theory = open('Results/CFA_r2_theory.tex', 'w')
text_latex_r2_theory.write(latex_r2_theory)
text_latex_r2_theory.close()

# --------------------------------------------
# TABLES CFA
# Mark van der Plaat
# December 2021
# --------------------------------------------
''' This script makes tables for the CFA securitization paper.

    All data is generated by Lavaan in R. See CFA_v1.R for more details.
'''

# --------------------------------------------
# Import Packages
# --------------------------------------------

# Data manipulation
import pandas as pd
import numpy as np

# Plotting
import matplotlib.pyplot as plt
import seaborn as sns

sns.set(style='whitegrid', font_scale=3)

import os

os.chdir(r'D:\RUG\PhD\Materials_papers\01-Note_on_securitization')

# --------------------------------------------
# Functions
# --------------------------------------------
# Function that sets a dictionary of variable names
def getVarDict():
    var_names = ['cr_as_sbo', 'cr_as_rmbs',
                 'cr_as_abs', 'hmda_sec_amount',
                 'cr_secveh_ta',
                 'cr_sec_income', 'cr_serv_fees',
                 'cr_cds_purchased', 'cr_abcp_ta',
                 'cr_abcp_uc_own', 'cr_abcp_ce_own',
                 'cr_abcp_uc_oth', 'cr_abcp_ce_oth']
    var_labels = ['Small Bus. Obl. Transf.', 'Sec. Residential Loans',
                  'Sec. Other Assets', 'Sec. Residential Mortgages',
                  'TA Sec. Vehicles',
                  'Sec. Income', 'Servicing Fees',
                  'CDSs Purchased', 'TA ABCP Conduits',
                  'Un. Com. Own ABCP Conduits',
                  'Credit Exp. Own ABCP Conduits', 'Un. Com. Other ABCP Conduits']
    var_dict = dict(zip(var_names, var_labels))

    return var_dict

# Set heatmap function 
def heatmap(matrix, file, annot=True):
    # Set mask
    mask = np.triu(np.ones_like(matrix, dtype=bool), 1)

    # Set aesthetics
    dic_aes = {'mask': mask,
               'annot': annot,
               'center': 0,
               'cmap': 'coolwarm',
               'fmt': '.3f'}

    # Make heatmap
    fig, ax = plt.subplots(figsize=(36, 24))
    sns.heatmap(matrix, **dic_aes)
    plt.tight_layout()

    # Save heatmap
    fig.savefig('Figures/CFA_covariance_maps/' + file)


# Function to make the parameter estimate table pretty
def tidyParamEst(data):
    # Select columns
    data_clean = data.iloc[:, [3, 4, 6, 10]]

    # Set column names
    data_clean.columns = ['Estimates', 'SD', 'P-value', 'Estimates (compl. std.)']

    # Set index names
    ## Prelims
    index_lst = list()
    lst_factors = ('SEC', 'ABCP', 'ABSCDO','LS')
    factor_labels = ('F1', 'F2', 'F1','F3')
    factor_dict = dict(zip(lst_factors, factor_labels))

    var_dict = getVarDict()

    ## Loop over rows to get the correct parameter name
    for index, row in data.iloc[:, :3].iterrows():
        if row['lhs'] in lst_factors:
            if row['rhs'] in lst_factors:
                if row['lhs'] == row['rhs']:
                    index_lst.append(['Variance ($\phi$)', str(factor_dict[row['lhs']]), np.nan])
                else:
                    index_lst.append(
                        ['Covariance ($\phi$)', str(factor_dict[row['lhs']]), str(factor_dict[row['rhs']])])
                # index_lst.append('$\phi_{' + str(row['lhs']) + ',' +  str(row['rhs']) +'}$')
            else:
                index_lst.append(['Loading ($\lambda$)', str(factor_dict[row['lhs']]), str(var_dict[row['rhs']])])
                # index_lst.append('$\lambda_{' + str(row['lhs']) + ',' +  str(var_dict[row['rhs']]) +'}$')
        else:
            if row['lhs'] == row['rhs']:
                index_lst.append(['Variance ($\delta$)', str(var_dict[row['lhs']]), np.nan])
            else:
                index_lst.append(['Covariance ($\delta$)', str(var_dict[row['lhs']]), str(var_dict[row['rhs']])])
            # index_lst.append('$\delta_{' + str(var_dict[row['lhs']]) + ',' +  str(var_dict[row['rhs']]) +'}$')

    ## Change Index
    data_index = list(map(list, zip(*index_lst)))
    data_clean = data_clean.assign(LHS=data_index[1],
                                   RHS=data_index[2])

    data_clean.set_index(['LHS', 'RHS'], inplace=True)

    ## Remove Index names
    data_clean.index.names = [None, None]

    return data_clean


# Function to make latex table from pandas dataframe
def table2Latex(data, options, notes, string_size):
    # Get latex table and
    latex_table = data.to_latex(na_rep='', float_format='{:0.4f}'.format,
                                longtable=False, multicolumn=True,
                                multicolumn_format='c', escape=False,
                                **options)

    # add notes to bottom of the table
    location_mid = latex_table.find('\end{tabular}')
    latex_table = latex_table[:location_mid] + notes + latex_table[location_mid:]

    # adjust sting size
    location_size = latex_table.find('\centering\n')
    latex_table = latex_table[:location_size + len('\centering\n')] + string_size + latex_table[location_size + len(
        '\centering\n'):]

    # Insert multicolumns for the fit measures
    if data.index[0] == 'No. Params':
        # Absolute fit
        abs_fit = '& \\\\ \n \\multicolumn{2}{l}{\\textbf{Absolute fit}} \\\\ \n'
        location = latex_table.find('Yuan--Bentler $\chi^2$')
        latex_table = latex_table[:location] + abs_fit + latex_table[location:]

        # Parsimonious fit
        pars_fit = '& \\\\ \n \\multicolumn{2}{l}{\\textbf{Parsimonious fit}} \\\\ \n'
        location = latex_table.find('RMSEA')
        latex_table = latex_table[:location] + pars_fit + latex_table[location:]

        # Comparative and relative fit
        cr_fit = '& \\\\ \n \\multicolumn{2}{l}{\\textbf{Comparative and relative fit}} \\\\ \n'
        location = latex_table.find('CFI')
        latex_table = latex_table[:location] + cr_fit + latex_table[location:]

        # Other
        oth_fit = '& \\\\ \n \\multicolumn{2}{l}{\\textbf{Other}} \\\\ \n'
        location = latex_table.find('AIC')
        latex_table = latex_table[:location] + oth_fit + latex_table[location:]

    # Insert multicolumns for the parameter estimates for two-factor model
    if (data.index[0][0] == 'F1') and (data.index[-1][0] != 'F3'):
        # Factor loadings
        factor_loadings = ' \n \\multicolumn{6}{l}{\\textbf{Factor loadings}} \\\\ \n'
        location = latex_table.find('F1')
        latex_table = latex_table[:location] + factor_loadings + latex_table[location:]

        # Error covariances (unique covariances)
        error_cov = '&&&&& \\\\ \n \\multicolumn{6}{l}{\\textbf{Error covariances}} \\\\ \n'
        location = latex_table.find('Un. Com. Own ABCP Conduits & Un. Com. Other ABCP Conduits')
        latex_table = latex_table[:location] + error_cov + latex_table[location:]

        # Unique variances
        if data.index.get_level_values(0).str.contains('F3').any():
            unique_var = '\n&&&&& \\\\ \n \\multicolumn{6}{l}{\\textbf{Unique variances}} \\\\'
            location = latex_table.find('\nSec. Residential Loans &')
            latex_table = latex_table[:location] + unique_var + latex_table[location:]
        else:
            unique_var = '\n&&&&& \\\\ \n \\multicolumn{6}{l}{\\textbf{Unique variances}} \\\\'
            location = latex_table.find('\nSmall Bus. Obl. Transf. &')
            latex_table = latex_table[:location] + unique_var + latex_table[location:]

        # Factor variances
        fac_var = '&&&&& \\\\ \n \\multicolumn{6}{l}{\\textbf{Factor variances}} \\\\ \n'
        location = latex_table.replace('F1', 'XX', 1).find('F1')  # trick to find the second ABSCDO
        latex_table = latex_table[:location] + fac_var + latex_table[location:]

        # Factor covariances
        fac_cov = '&&&&& \\\\ \n \\multicolumn{6}{l}{\\textbf{Factor covariances}} \\\\ \n'
        location = latex_table.find('F1 & F2')
        latex_table = latex_table[:location] + fac_cov + latex_table[location:]

    # Insert multicolumns for the parameter estimates for one-factor model
    if data.index[-1][0] == 'F3':
        # Factor loadings
        factor_loadings = ' \n \\multicolumn{6}{l}{\\textbf{Factor loadings}} \\\\ \n'
        location = latex_table.find('F1')
        latex_table = latex_table[:location] + factor_loadings + latex_table[location:]

        # Error covariances (unique covariances)
        error_cov = '&&&&& \\\\ \n \\multicolumn{6}{l}{\\textbf{Error covariances}} \\\\ \n'
        location = latex_table.find('\nUn. Com. Own ABCP Conduits & Un. Com. Other ABCP Conduits')
        latex_table = latex_table[:location] + error_cov + latex_table[location:]

        # Unique variances
        unique_var = '\n&&&&& \\\\ \n \\multicolumn{6}{l}{\\textbf{Unique variances}} \\\\'
        location = latex_table.find('\nSmall Bus. Obl. Transf. &')
        latex_table = latex_table[:location] + unique_var + latex_table[location:]

        # Factor variances
        fac_var = '&&&&& \\\\ \n \\multicolumn{6}{l}{\\textbf{Factor variances}} \\\\ \n'
        location = latex_table.replace('F1', 'XX', 2).find('F1')
        latex_table = latex_table[:location] + fac_var + latex_table[location:]

        # Insert multi columns in the communality table
    if data.columns[-1] == 'Source':
        # ABS sec
        col = ' \\multicolumn{3}{l}{\\textbf{Loading only on F1}} \\\\ \n'
        location = latex_table.find('Small Bus. Obl. Transf.')
        latex_table = latex_table[:location] + col + latex_table[location:]

        # Both factors
        col = '&&&\\\\ \n \\multicolumn{3}{l}{\\textbf{Loading on both F1 and F2}} \\\\ \n'
        location = latex_table.find('Sec. Income')
        latex_table = latex_table[:location] + col + latex_table[location:]

        # ABCP factors
        col = '&&&\\\\ \n \\multicolumn{3}{l}{\\textbf{Loading only on F2}} \\\\ \n'
        location = latex_table.find('TA ABCP Conduits')
        latex_table = latex_table[:location] + col + latex_table[location:]

    return latex_table


def tidyFitInd(data):
    # Get indices
    lst_fi = ['npar', 'df', 'baseline.df', 'chisq.scaled',
              'pvalue.scaled','srmr', 'rmsea.robust',
              'rni.robust', 'cfi.robust', 'tli.robust', 'aic', 'bic']

    data_clean = data.loc[lst_fi, :]

    # Rename index
    lst_fi_labels = ['No. Params', 'DoF', 'DoF baseline','Yuan--Bentler $\chi^2$',
                     'p-val Yuan--Bentler $\chi^2$', 'SRMR', 'RMSEA',
                     'RNI', 'CFI', 'TLI',
                     'AIC', 'BIC']
    data_clean.index = lst_fi_labels

    # Rename columns
    if data.shape[1] == 3:
        data_clean.columns = ['Theory', 'EFA', 'Combined']
    if data.shape[1] == 2:
        data_clean.columns = ['(1)', '(2)']
    else:
        data_clean.rename(columns={'Unnamed: 1': 'Index'}, inplace=True)

    # Format values
    data_clean = data_clean.applymap(lambda x: '{:,.4f}'.format(x) if not 24 <= x <= 66 else '{:,.0f}'.format(x))

    return data_clean


# Function to make the modification table table pretty
def pivotTableMI(data, value = 'mi'):
    # Pivot table
    data_pivot = data.pivot(index='rhs', columns='lhs', values=value)

    # Split table into two: 1) Loadings, 2) Covariances
    # Only for two factor models
    var_names = list(getVarDict().keys())

    if data_pivot.columns.str.contains('ABSCDO|ABCP').any() and not data_pivot.columns.str.contains('LS').any():
        data_load = data_pivot.iloc[:,:2]
        data_cov = data_pivot.iloc[:,2:]

        # Sort index/columns tables
        if data_cov.shape[0] == 12:
            try:
                data_load = data_load.loc[var_names, :]
                data_cov = data_cov.loc[var_names[1:], var_names[:-1]]
            except:
                var_names = [name for name in var_names if
                         name not in ['cr_cds_purchased']] + ['cr_cds_purchased']
                data_load = data_load.loc[var_names, :]
                data_cov = data_cov.loc[var_names[1:], var_names[:-1]]
        else:
            var_names = [name for name in var_names if
                         name not in ['cr_as_sbo', 'hmda_sec_amount', 'cr_cds_purchased']] + ['cr_cds_purchased']
            data_load = data_load.loc[var_names, :]
            data_cov = data_cov.loc[var_names[1:], var_names[:-1]]

        # Remove index and column names
        data_load.index.name = None
        data_load.columns.name = None

        data_cov.index.name = None
        data_cov.columns.name = None
    elif data_pivot.columns.str.contains('LS').any():
        data_load = data_pivot.iloc[:, :3]
        data_cov = data_pivot.iloc[:, 3:]

        # Sort index/columns tables
        data_load = data_load.loc[var_names, :]
        var_names = [name for name in var_names if
                     name not in ['cr_as_sbo']] + ['cr_as_sbo']
        data_cov = data_cov.loc[var_names[1:], var_names[:-1]]

        # Remove index and column names
        data_load.index.name = None
        data_load.columns.name = None

        data_cov.index.name = None
        data_cov.columns.name = None
    else:
        data_load = None
        data_cov = data_pivot

        # Sort index/columns
        data_cov = data_cov.loc[var_names[1:], var_names[:-1]]

        # Remove index and column names
        data_cov.index.name = None
        data_cov.columns.name = None

    # return tables
    return data_load, data_cov

def tidyModInd(data):
    # Get tables for MI and EPC
    data_mi_load, data_mi_cov = pivotTableMI(data, 'mi')
    data_epc_load, data_epc_cov = pivotTableMI(data, 'sepc.all')

    # Set column and index names
    var_dict = getVarDict()

    if isinstance(data_mi_load, pd.DataFrame):
        if data_mi_load.shape[1] == 2:
            data_mi_load.columns = [('Mod. Indices','F2'),('Mod. Indices','F1')]
            data_mi_load.rename(var_dict, axis=0, inplace = True)

            data_epc_load.columns = [('EPC (Compl. Std.)', 'F2'), ('EPC (Compl. Std.)', 'F1')]
            data_epc_load.rename(var_dict, axis=0, inplace=True)
        else:
            data_mi_load.columns = [('Mod. Indices', 'F2'), ('Mod. Indices', 'F1'), ('Mod. Indices', 'F3')]
            data_mi_load.rename(var_dict, axis=0, inplace=True)

            data_epc_load.columns = [('EPC (Compl. Std.)', 'F2'), ('EPC (Compl. Std.)', 'F1'), ('EPC (Compl. Std.)', 'F3')]
            data_epc_load.rename(var_dict, axis=0, inplace=True)

        # Concat loadings table and sort columns
        data_load = pd.concat([data_mi_load, data_epc_load], axis=1)
        data_load = data_load.reindex(sorted(data_load.columns), axis=1)

        # Remove nan-columns in loadings table
        data_load = data_load.loc[~data_load.isnull().all(axis=1), :]

        # Make multicolumn for loadings table
        data_load.columns = pd.MultiIndex.from_tuples(data_load.columns,
                                                      names=['', ''])
    else:
        data_load = None

    data_mi_cov.rename(var_dict, axis=0, inplace=True)
    data_mi_cov.rename(var_dict, axis=1, inplace=True)

    data_epc_cov.rename(var_dict, axis=0, inplace=True)
    data_epc_cov.rename(var_dict, axis=1, inplace=True)

    # Return data
    return data_load, data_mi_cov, data_epc_cov

# --------------------------------------------
# Prelims
# --------------------------------------------
dict_vars = getVarDict()

# Add Factor names
dict_vars.update({'LS': 'Loan Sales',
                  'ABS': 'ABS Sec.',
                  'CDO': 'CDO Sec.',
                  'ABCP': 'ABCP Sec.',
                  'SEC': 'Securitization'})

# --------------------------------------------
# Load data 
# --------------------------------------------

# fit indices 
df_fi_onesec = pd.read_csv('Results/CFA_fitmeasures_onesec.csv', index_col=0)

df_fi_efa = pd.read_csv('Results/CFA_fitmeasures_efa.csv', index_col=0)
df_fi_theory = pd.read_csv('Results/CFA_fitmeasures_theory.csv', index_col=0)
df_fi_combined = pd.read_csv('Results/CFA_fitmeasures_combined.csv', index_col=0)

df_fi_3f = pd.read_csv('Results/CFA_fitmeasures_sboseparate.csv', index_col=0)
df_fi_theory_extra = pd.read_csv('Results/CFA_fitmeasures_theory_extra.csv', index_col=0)

# Parameter estimates
df_params_onesec = pd.read_csv('Results/CFA_params_onesec.csv', index_col=0)

df_params_efa = pd.read_csv('Results/CFA_params_efa.csv', index_col=0)
df_params_theory = pd.read_csv('Results/CFA_params_theory.csv', index_col=0)
df_params_combined = pd.read_csv('Results/CFA_params_combined.csv', index_col=0)

df_params_3f = pd.read_csv('Results/CFA_params_sboseparate.csv', index_col=0)
df_params_theory_extra = pd.read_csv('Results/CFA_params_theory_extra.csv', index_col=0)

# Reliability measures
df_reliability_efa = pd.read_csv('Results/CFA_reliability_efa.csv', index_col=0)
df_reliability_theory = pd.read_csv('Results/CFA_reliability_theory.csv', index_col=0)
df_reliability_combined = pd.read_csv('Results/CFA_reliability_combined.csv', index_col=0)

# Modification indices
df_mi_onesec = pd.read_csv('Results/CFA_modindices_onesec.csv', index_col=0)

df_mi_efa = pd.read_csv('Results/CFA_modindices_efa.csv', index_col=0)
df_mi_theory = pd.read_csv('Results/CFA_modindices_theory.csv', index_col=0)
df_mi_combined = pd.read_csv('Results/CFA_modindices_combined.csv', index_col=0)

df_mi_3f = pd.read_csv('Results/CFA_modindices_sboseparate.csv', index_col=0)
df_mi_theory_extra = pd.read_csv('Results/CFA_modindices_theory_extra.csv', index_col=0)

# Model implied covariance matrix
df_micm_theory = pd.read_csv('Results/CFA_modimplied_cov_theory.csv', index_col=0)

# Residual covariance matrix
df_srcm_onesec = pd.read_csv('Results/CFA_rescov_standard_onesec.csv', index_col=0)

df_rcm_theory = pd.read_csv('Results/CFA_rescov_theory.csv', index_col=0)
df_srcm_theory = pd.read_csv('Results/CFA_rescov_standard_theory.csv', index_col=0)

df_srcm_efa = pd.read_csv('Results/CFA_rescov_standard_efa.csv', index_col=0)
df_srcm_combined = pd.read_csv('Results/CFA_rescov_standard_combined.csv', index_col=0)

df_srcm_3f = pd.read_csv('Results/CFA_rescov_standard_sboseparate.csv', index_col=0)
df_srcm_theory_extra = pd.read_csv('Results/CFA_rescov_standard_theory_extra.csv', index_col=0)

# Communalities
df_r2_theory = pd.read_csv('Results/CFA_r2_theory.csv', index_col=0)

# --------------------------------------------
# fit indices 
# --------------------------------------------

# One securization factor
## Get tidy table
df_fi_onesec_tidy = tidyFitInd(df_fi_onesec)

## To latex
### Prelims
dict_options = {'column_format': 'p{3cm}' + 'p{1.5cm}' * df_fi_onesec_tidy.shape[1],
                'caption': ('Fit Indices: One Securitization Factor Model'),
                'label': 'tab:cfa_fit_onesec',
                'position': 'th'}
notes = '\\multicolumn{2}{p{4.5cm}}{\\textit{Notes.} Fit indices of the model with one securitization factor.} \n'
string_size = '\\scriptsize\n'

### Get latex table and save
latex_fi_onesec = table2Latex(df_fi_onesec_tidy, dict_options, notes, string_size)
text_latex_fi_onesec = open('Results/CFA_fi_onesec.tex', 'w')
text_latex_fi_onesec.write(latex_fi_onesec)
text_latex_fi_onesec.close()

# All two factor models
## Get tidy table
df_fi_2f = pd.concat([df_fi_theory, df_fi_efa, df_fi_combined], axis=1)
df_fi_2f_tidy = tidyFitInd(df_fi_2f)

## To latex
### Prelims
dict_options = {'column_format': 'p{3cm}' + 'p{1.5cm}' * df_fi_2f_tidy.shape[1],
                'caption': ('Fit Indices: Two-factor Models'),
                'label': 'tab:cfa_fit_twofactor_models',
                'position': 'th'}
notes = '\\multicolumn{4}{p{9cm}}{\\textit{Notes.} Fit indices of the two-factor models. The first column contains the fit indices for the theory-based model, and the second column the EFA-based model. The last column presents the fit indices for the model where we combine exploratory factor analysis and Table \\ref{tab:possible_proxies}.} \n'
string_size = '\\scriptsize\n'

### Get latex table and save
latex_fi_2f = table2Latex(df_fi_2f_tidy, dict_options, notes, string_size)
text_latex_latex_fi_2f = open('Results/CFA_fi_2f.tex', 'w')
text_latex_latex_fi_2f.write(latex_fi_2f)
text_latex_latex_fi_2f.close()

# Theory extra model
## Get tidy table
df_fi_theory_extra_tidy = tidyFitInd(df_fi_theory_extra)

## To latex
### Prelims
dict_options = {'column_format': 'p{3cm}' + 'p{1.5cm}' * df_fi_theory_extra_tidy.shape[1],
                'caption': ('Fit Indices: Two-Factor Theory Model (Extra Covariances)'),
                'label': 'tab:cfa_fit_theory_extra',
                'position': 'th'}
notes = '\\multicolumn{2}{p{4.5cm}}{\\textit{Notes.} Fit indices of the two-factor theory model with extra error covariances.} \n'
string_size = '\\scriptsize\n'

### Get latex table and save
latex_fi_onesec = table2Latex(df_fi_theory_extra_tidy, dict_options, notes, string_size)
text_latex_fi_onesec = open('Results/CFA_fi_theory_extra.tex', 'w')
text_latex_fi_onesec.write(latex_fi_onesec)
text_latex_fi_onesec.close()

# Three factor model
## Get tidy table
df_fi_3f_tidy = tidyFitInd(df_fi_3f)

## To latex
### Prelims
dict_options = {'column_format': 'p{3cm}' + 'p{1.5cm}' * df_fi_3f_tidy.shape[1],
                'caption': ('Fit Indices: Three-Factor Model'),
                'label': 'tab:cfa_fit_3f',
                'position': 'th'}
notes = '\\multicolumn{2}{p{4.5cm}}{\\textit{Notes.} Fit indices of the three-factor theory model. The extra factor measures \\textit{Small Business Obligations Transferred}. } \n'
string_size = '\\scriptsize\n'

### Get latex table and save
latex_fi_onesec = table2Latex(df_fi_3f_tidy, dict_options, notes, string_size)
text_latex_fi_onesec = open('Results/CFA_fi_3f.tex', 'w')
text_latex_fi_onesec.write(latex_fi_onesec)
text_latex_fi_onesec.close()

# --------------------------------------------
# Parameter estimates 
# --------------------------------------------

# One securitization factor
## Get tidy table
df_params_onesec_tidy = tidyParamEst(df_params_onesec)

## To latex
### Prelims
dict_options = {'column_format': 'p{4.75cm}p{4.75cm}' + 'p{1cm}' * df_params_onesec_tidy.shape[1],
                'caption': ('Factor Loadings, Variances and Covariances: One Securitization Factor Model'),
                'label': 'tab:cfa_table_onesec',
                'position': 'th'}
notes = '\\multicolumn{6}{p{16cm}}{\\textit{Notes.} Factor loadings, factor variance, and unique variances and covariances of the factor model with one factor. The last column presents the completely standardized estimates, where the factor variances are fixed to one and all other proxies are standardized.} \n'
string_size = '\\scriptsize\n'

### Get latex table and save
latex_params_onesec = table2Latex(df_params_onesec_tidy, dict_options, notes, string_size)
latex_params_onesec = latex_params_onesec[:-64] # Remove unwanted factor covariance multicolumn
text_latex_params_onesec = open('Results/CFA_params_onesec.tex', 'w')
text_latex_params_onesec.write(latex_params_onesec)
text_latex_params_onesec.close()

# Two factors: EFA
## Get tidy table
df_params_efa_tidy = tidyParamEst(df_params_efa)

## To latex
### Prelims
dict_options = {'column_format': 'p{4.75cm}p{4.75cm}' + 'p{1cm}' * df_params_efa_tidy.shape[1],
                'caption': ('Factor Loadings, Variances and Covariances: Two-factor EFA Model'),
                'label': 'tab:cfa_table_2fefa',
                'position': 'th'}
notes = '\\multicolumn{6}{p{16cm}}{\\textit{Notes.} Factor loadings, factor variances and covariances, and unique variances and covariances of the two-factor model based on the exploratory factor analysis (EFA). The last column presents the completely standardized estimates, where the factor variances are fixed to one and all other proxies are standardized.} \n'
string_size = '\\scriptsize\n'

### Get latex table and save
latex_params_efa = table2Latex(df_params_efa_tidy, dict_options, notes, string_size)
text_latex_params_onesec = open('Results/CFA_params_efa.tex', 'w')
text_latex_params_onesec.write(latex_params_efa)
text_latex_params_onesec.close()

# Two factors: Theory
df_params_theory_tidy = tidyParamEst(df_params_theory)

## To latex
### Prelims
dict_options = {'column_format': 'p{4.75cm}p{4.75cm}' + 'p{1cm}' * df_params_theory_tidy.shape[1],
                'caption': ('Factor Loadings, Variances and Covariances: Two-factor Theory Model'),
                'label': 'tab:cfa_table_2ftheory',
                'position': 'th'}
notes = '\\multicolumn{6}{p{16cm}}{\\textit{Notes.} Factor loadings, factor variances and covariances, and unique variances and covariances of the two-factor model based on Table \\ref{tab:possible_proxies}. The last column presents the completely standardized estimates, where the factor variances are fixed to one and all other proxies are standardized.} \n'
string_size = '\\scriptsize\n'

### Get latex table and save
latex_params_theory = table2Latex(df_params_theory_tidy, dict_options, notes, string_size)
text_latex_params_theory = open('Results/CFA_params_theory.tex', 'w')
text_latex_params_theory.write(latex_params_theory)
text_latex_params_theory.close()

# Two factors: Combined
df_params_combined_tidy = tidyParamEst(df_params_combined)

## To latex
### Prelims
dict_options = {'column_format': 'p{4.75cm}p{4.75cm}' + 'p{1cm}' * df_params_combined_tidy.shape[1],
                'caption': ('Factor Loadings, Variances and Covariances: Two-factor Combined Model'),
                'label': 'tab:cfa_table_2fcombined',
                'position': 'th'}
notes = '\\multicolumn{6}{p{16cm}}{\\textit{Notes.} Factor loadings, factor variances and covariances, and unique variances and covariances of the two-factor model based on the exploratory factor analysis (EFA) and Table \\ref{tab:possible_proxies}. The last column presents the completely standardized estimates, where the factor variances are fixed to one and all other proxies are standardized.} \n'
string_size = '\\scriptsize\n'

### Get latex table and save
latex_params_combined = table2Latex(df_params_combined_tidy, dict_options, notes, string_size)
text_latex_params_combined = open('Results/CFA_params_combined.tex', 'w')
text_latex_params_combined.write(latex_params_combined)
text_latex_params_combined.close()

# Two factors: Theory Extra
df_params_theory_extra_tidy = tidyParamEst(df_params_theory_extra)

## To latex
### Prelims
dict_options = {'column_format': 'p{4.75cm}p{4.75cm}' + 'p{1cm}' * df_params_theory_extra_tidy.shape[1],
                'caption': ('Factor Loadings, Variances and Covariances: Two-factor Theory Model (Extra Covariances)'),
                'label': 'tab:cfa_table_2ftheory_extra',
                'position': 'th'}
notes = '\\multicolumn{6}{p{16cm}}{\\textit{Notes.} Factor loadings, factor variances and covariances, and unique variances and covariances of the two-factor model based on Table \\ref{tab:possible_proxies} with extra error covariances based on the modification indices and EPCs of the two-factor theory model. The last column presents the completely standardized estimates, where the factor variances are fixed to one and all other proxies are standardized.} \n'
string_size = '\\scriptsize\n'

### Get latex table and save
latex_params_theory = table2Latex(df_params_theory_extra_tidy, dict_options, notes, string_size)
text_latex_params_theory = open('Results/CFA_params_theory_extra.tex', 'w')
text_latex_params_theory.write(latex_params_theory)
text_latex_params_theory.close()

# Three factors
df_params_3f_tidy = tidyParamEst(df_params_3f)

## To latex
### Prelims
dict_options = {'column_format': 'p{4.75cm}p{4.75cm}' + 'p{1cm}' * df_params_3f_tidy.shape[1],
                'caption': ('Factor Loadings, Variances and Covariances: Two-factor Theory Model (Extra Covariances)'),
                'label': 'tab:cfa_table_3f',
                'position': 'th'}
notes = '\\multicolumn{6}{p{16cm}}{\\textit{Notes.} Factor loadings, factor variances and covariances, and unique variances and covariances of the three-factor model. The last column presents the completely standardized estimates, where the factor variances are fixed to one and all other proxies are standardized.} \n'
string_size = '\\scriptsize\n'

### Get latex table and save
latex_params_theory = table2Latex(df_params_3f_tidy, dict_options, notes, string_size)
text_latex_params_theory = open('Results/CFA_params_3f.tex', 'w')
text_latex_params_theory.write(latex_params_theory)
text_latex_params_theory.close()

# --------------------------------------------
#  Reliability
# --------------------------------------------

# Two-factor models
df_reliability = pd.concat([df_reliability_efa.loc['omega', :],
                            df_reliability_theory.loc['omega', :],
                            df_reliability_combined.loc['omega', :]], axis=1)

df_reliability.columns = ['EFA', 'Theory', 'Combined']
df_reliability.index = ['F1', 'F2']

## To latex
### Prelims
dict_options = {'column_format': 'p{4cm}' + 'p{1cm}' * df_reliability.T.shape[1],
                'caption': ('Scale Reliability Two-factor models'),
                'label': 'tab:cfa_reliability_2f',
                'position': 'th'}
notes = '\\multicolumn{3}{p{6cm}}{\\textit{Notes.} Scale reliability for all two-factor models. } \n'
string_size = '\\scriptsize\n'

### Get latex table and save
latex_params_reliability = table2Latex(df_reliability.T, dict_options, notes, string_size)
text_latex_params_reliability = open('Results/CFA_scale_reliability_2f.tex', 'w')
text_latex_params_reliability.write(latex_params_reliability)
text_latex_params_reliability.close()

# --------------------------------------------
#  Model implied covariance matrix 
# --------------------------------------------

# Theory model
heatmap(df_micm_theory.rename(columns=dict_vars, index=dict_vars), 'Modelimplied_cov_heatmap_theory.png')

# --------------------------------------------
# Residual covariance matrix
# --------------------------------------------

# One factor model
heatmap(df_srcm_onesec.rename(columns=dict_vars, index=dict_vars), 'Residual_cov_std_heatmap_onesec.png')

# Theory model
heatmap(df_rcm_theory.rename(columns=dict_vars, index=dict_vars), 'Residual_cov_heatmap_theory.png')
heatmap(df_srcm_theory.rename(columns=dict_vars, index=dict_vars), 'Residual_cov_std_heatmap_theory.png')

# EFA model
heatmap(df_srcm_efa.rename(columns=dict_vars, index=dict_vars), 'Residual_cov_std_heatmap_efa.png')

# Combined model
heatmap(df_srcm_combined.rename(columns=dict_vars, index=dict_vars), 'Residual_cov_std_heatmap_combined.png')

# Theory Extra
heatmap(df_srcm_theory_extra.rename(columns=dict_vars, index=dict_vars), 'Residual_cov_std_heatmap_theory_extra.png')

# Three-factor model
heatmap(df_srcm_3f.rename(columns=dict_vars, index=dict_vars), 'Residual_cov_std_heatmap_3f.png')

# --------------------------------------------
# Modification indices 
# --------------------------------------------

# One factor model (the 1f model does not have factor loading MIs/EPCs)
## Get tidy tables
df_miepc_onesec_load, df_mi_cov_onesec, df_epc_cov_onesec = tidyModInd(df_mi_onesec)

## To latex
### MI Covariances
dict_options = {'column_format': 'p{4.75cm}' + 'p{1cm}' * df_mi_cov_onesec.shape[1],
                'caption': ('Modification Indices of the Covariances: One-factor Model'),
                'label': 'tab:cfa_mi_cov_onesec',
                'position': 'th'}
notes = '\\multicolumn{12}{p{20.5cm}}{\\textit{Notes.} Modification indices of the one-factor model. The table only displays the modification indices for freeing error covariances. The modification indices relect a drop in the unscaled $\chi^2$ statistic after freeing a previously fixed parameter.} \n'
string_size = '\\scriptsize\n'

latex_miepc = table2Latex(df_mi_cov_onesec, dict_options, notes, string_size)
latex_miepc = latex_miepc.replace('table','sidewaystable')
text_latex_miepc = open('Results/CFA_mi_onesec_cov.tex', 'w')
text_latex_miepc.write(latex_miepc)
text_latex_miepc.close()

### EPC Covariances
dict_options = {'column_format': 'p{4.75cm}' + 'p{1cm}' * df_epc_cov_onesec.shape[1],
                'caption': ('EPCs of the Covariances: Two-factor Theory Model'),
                'label': 'tab:cfa_epc_cov_onesec',
                'position': 'th'}
notes = '\\multicolumn{12}{p{20.5cm}}{\\textit{Notes.} Completely standardized expected parameter change (EPC) of the one-factor model. The table only displays the EPCs for freeing error covariances. The EPCs show the expected change in a parameter estimate if it were freely estimated.} \n'
string_size = '\\scriptsize\n'

latex_miepc = table2Latex(df_epc_cov_onesec, dict_options, notes, string_size)
latex_miepc = latex_miepc.replace('table','sidewaystable')
text_latex_miepc = open('Results/CFA_epc_onesec_cov.tex', 'w')
text_latex_miepc.write(latex_miepc)
text_latex_miepc.close()

# Theory
## Get tidy tables
df_miepc_theory_load, df_mi_cov_theory, df_epc_cov_theory = tidyModInd(df_mi_theory)

## To latex
### MI EPC loadings
dict_options = {'column_format': 'p{4.75cm}' + 'p{1.5cm}' * df_miepc_theory_load.shape[1],
                'caption': ('Modification Indices and EPCs of the Factor Loadings: Two-factor Theory Model'),
                'label': 'tab:cfa_mipec_load_theory',
                'position': 'th'}
notes = '\\multicolumn{5}{p{13cm}}{\\textit{Notes.} Modification indices and the completely standardized expected parameter change (EPC) of the two-factor theory model. The table only displays the modification indices and EPCs for freeing factor loadings. See tables \\ref{tab:cfa_mi_cov_theory} and \\ref{tab:cfa_epc_cov_theory} for the modification indices and EPCs for freeing covariances. The proxies for \\textit{securitization income}, \\textit{servicing fees} and \\textit{credit default swaps purchased} do not have any modification indices and EPCs for factor loadings, because they already load on both factors. The modification indices relect a drop in the unscaled $\chi^2$ statistic after freeing a previously fixed parameter. The EPCs show the expected change in a parameter estimate if it were freely estimated.} \n'
string_size = '\\scriptsize\n'

latex_miepc = table2Latex(df_miepc_theory_load, dict_options, notes, string_size)
text_latex_miepc = open('Results/CFA_miepc_theory_load.tex', 'w')
text_latex_miepc.write(latex_miepc)
text_latex_miepc.close()

### MI Covariances
dict_options = {'column_format': 'p{4.75cm}' + 'p{1cm}' * df_mi_cov_theory.shape[1],
                'caption': ('Modification Indices of the Covariances: Two-factor Theory Model'),
                'label': 'tab:cfa_mi_cov_theory',
                'position': 'th'}
notes = '\\multicolumn{12}{p{20.5cm}}{\\textit{Notes.} Modification indices of the two-factor theory model. The table only displays the modification indices for freeing error covariances. See table \\ref{tab:cfa_mipec_load_theory} for the modification indices and EPCs of freeing factor loadings, and table \\ref{tab:cfa_epc_cov_theory} for the EPCs for freeing error covariances. The modification indices relect a drop in the unscaled $\chi^2$ statistic after freeing a previously fixed parameter.} \n'
string_size = '\\scriptsize\n'

latex_miepc = table2Latex(df_mi_cov_theory, dict_options, notes, string_size)
latex_miepc = latex_miepc.replace('table','sidewaystable')
text_latex_miepc = open('Results/CFA_mi_theory_cov.tex', 'w')
text_latex_miepc.write(latex_miepc)
text_latex_miepc.close()

### EPC Covariances
dict_options = {'column_format': 'p{4.75cm}' + 'p{1cm}' * df_epc_cov_theory.shape[1],
                'caption': ('EPCs of the Covariances: Two-factor Theory Model'),
                'label': 'tab:cfa_epc_cov_theory',
                'position': 'th'}
notes = '\\multicolumn{12}{p{20.5cm}}{\\textit{Notes.} Completely standardized expected parameter change (EPC) of the two-factor theory model. The table only displays the EPCs for freeing error covariances. See table \\ref{tab:cfa_mipec_load_theory} for the modification indices and EPCs of freeing factor loadings, and table \\ref{tab:cfa_mi_cov_theory} for the modification indices for freeing error covariances. The EPCs show the expected change in a parameter estimate if it were freely estimated.} \n'
string_size = '\\scriptsize\n'

latex_miepc = table2Latex(df_epc_cov_theory, dict_options, notes, string_size)
latex_miepc = latex_miepc.replace('table','sidewaystable')
text_latex_miepc = open('Results/CFA_epc_theory_cov.tex', 'w')
text_latex_miepc.write(latex_miepc)
text_latex_miepc.close()

# EFA
## Get tidy tables
df_miepc_efa_load, df_mi_cov_efa, df_epc_cov_efa = tidyModInd(df_mi_efa)

## To latex
### MI EPC loadings
dict_options = {'column_format': 'p{4.75cm}' + 'p{1.5cm}' * df_miepc_efa_load.shape[1],
                'caption': ('Modification Indices and EPCs of the Factor Loadings: Two-factor EFA Model'),
                'label': 'tab:cfa_mipec_load_efa',
                'position': 'th'}
notes = '\\multicolumn{5}{p{13cm}}{\\textit{Notes.} Modification indices and the completely standardized expected parameter change (EPC) of the two-factor EFA model. The table only displays the modification indices and EPCs for freeing factor loadings. The modification indices relect a drop in the unscaled $\chi^2$ statistic after freeing a previously fixed parameter. The EPCs show the expected change in a parameter estimate if it were freely estimated.} \n'
string_size = '\\scriptsize\n'

latex_miepc = table2Latex(df_miepc_efa_load, dict_options, notes, string_size)
text_latex_miepc = open('Results/CFA_miepc_efa_load.tex', 'w')
text_latex_miepc.write(latex_miepc)
text_latex_miepc.close()

### MI Covariances
dict_options = {'column_format': 'p{4.75cm}' + 'p{1cm}' * df_mi_cov_efa.shape[1],
                'caption': ('Modification Indices of the Covariances: Two-factor EFA Model'),
                'label': 'tab:cfa_mi_cov_efa',
                'position': 'th'}
notes = '\\multicolumn{10}{p{18.5cm}}{\\textit{Notes.} Modification indices of the two-factor EFA model. The table only displays the modification indices for freeing error covariances. The modification indices relect a drop in the unscaled $\chi^2$ statistic after freeing a previously fixed parameter.} \n'
string_size = '\\scriptsize\n'

latex_miepc = table2Latex(df_mi_cov_efa, dict_options, notes, string_size)
latex_miepc = latex_miepc.replace('table','sidewaystable')
text_latex_miepc = open('Results/CFA_mi_efa_cov.tex', 'w')
text_latex_miepc.write(latex_miepc)
text_latex_miepc.close()

### EPC Covariances
dict_options = {'column_format': 'p{4.75cm}' + 'p{1cm}' * df_epc_cov_efa.shape[1],
                'caption': ('EPCs of the Covariances: Two-factor EFA Model'),
                'label': 'tab:cfa_epc_cov_efa',
                'position': 'th'}
notes = '\\multicolumn{10}{p{18.5cm}}{\\textit{Notes.} Completely standardized expected parameter change (EPC) of the two-factor EFA model. The table only displays the EPCs for freeing error covariances. The EPCs show the expected change in a parameter estimate if it were freely estimated.} \n'
string_size = '\\scriptsize\n'

latex_miepc = table2Latex(df_epc_cov_efa, dict_options, notes, string_size)
latex_miepc = latex_miepc.replace('table','sidewaystable')
text_latex_miepc = open('Results/CFA_epc_efa_cov.tex', 'w')
text_latex_miepc.write(latex_miepc)
text_latex_miepc.close()

# Combined
## Get tidy tables
df_miepc_combined_load, df_mi_cov_combined, df_epc_cov_combined = tidyModInd(df_mi_combined)

## To latex
### MI EPC loadings
dict_options = {'column_format': 'p{4.75cm}' + 'p{1.5cm}' * df_miepc_combined_load.shape[1],
                'caption': ('Modification Indices and EPCs of the Factor Loadings: Two-factor Combined Model'),
                'label': 'tab:cfa_mipec_load_combined',
                'position': 'th'}
notes = '\\multicolumn{5}{p{13cm}}{\\textit{Notes.} Modification indices and the completely standardized expected parameter change (EPC) of the two-factor Combined model. The table only displays the modification indices and EPCs for freeing factor loadings. The modification indices relect a drop in the unscaled $\chi^2$ statistic after freeing a previously fixed parameter. The EPCs show the expected change in a parameter estimate if it were freely estimated.} \n'
string_size = '\\scriptsize\n'

latex_miepc = table2Latex(df_miepc_combined_load, dict_options, notes, string_size)
text_latex_miepc = open('Results/CFA_miepc_combined_load.tex', 'w')
text_latex_miepc.write(latex_miepc)
text_latex_miepc.close()

### MI Covariances
dict_options = {'column_format': 'p{4.75cm}' + 'p{1cm}' * df_mi_cov_combined.shape[1],
                'caption': ('Modification Indices of the Covariances: Two-factor Combined Model'),
                'label': 'tab:cfa_mi_cov_combined',
                'position': 'th'}
notes = '\\multicolumn{12}{p{20.5cm}}{\\textit{Notes.} Modification indices of the two-factor Combined model. The table only displays the modification indices for freeing error covariances. The modification indices relect a drop in the unscaled $\chi^2$ statistic after freeing a previously fixed parameter.} \n'
string_size = '\\scriptsize\n'

latex_miepc = table2Latex(df_mi_cov_combined, dict_options, notes, string_size)
latex_miepc = latex_miepc.replace('table','sidewaystable')
text_latex_miepc = open('Results/CFA_mi_combined_cov.tex', 'w')
text_latex_miepc.write(latex_miepc)
text_latex_miepc.close()

### EPC Covariances
dict_options = {'column_format': 'p{4.75cm}' + 'p{1cm}' * df_epc_cov_combined.shape[1],
                'caption': ('EPCs of the Covariances: Two-factor Combined Model'),
                'label': 'tab:cfa_epc_cov_combined',
                'position': 'th'}
notes = '\\multicolumn{12}{p{20.5cm}}{\\textit{Notes.} Completely standardized expected parameter change (EPC) of the two-factor Combined model. The table only displays the EPCs for freeing error covariances. The EPCs show the expected change in a parameter estimate if it were freely estimated.} \n'
string_size = '\\scriptsize\n'

latex_miepc = table2Latex(df_epc_cov_combined, dict_options, notes, string_size)
latex_miepc = latex_miepc.replace('table','sidewaystable')
text_latex_miepc = open('Results/CFA_epc_combined_cov.tex', 'w')
text_latex_miepc.write(latex_miepc)
text_latex_miepc.close()

# Theory Extra
## Get tidy tables
df_miepc_theory_extra_load, df_mi_cov_theory_extra, df_epc_cov_theory_extra = tidyModInd(df_mi_theory_extra)

## To latex
### MI EPC loadings
dict_options = {'column_format': 'p{4.75cm}' + 'p{1.5cm}' * df_miepc_theory_extra_load.shape[1],
                'caption': ('Modification Indices and EPCs of the Factor Loadings: Two-factor Theory Model (Extra Covariances)'),
                'label': 'tab:cfa_mipec_load_theory_extra',
                'position': 'th'}
notes = '\\multicolumn{5}{p{13cm}}{\\textit{Notes.} Modification indices and the completely standardized expected parameter change (EPC) of the two-factor theory model with extra error covariances. The table only displays the modification indices and EPCs for freeing factor loadings. The proxies for \\textit{securitization income}, \\textit{servicing fees} and \\textit{credit default swaps purchased} do not have any modification indices and EPCs for factor loadings, because they already load on both factors. The modification indices relect a drop in the unscaled $\chi^2$ statistic after freeing a previously fixed parameter. The EPCs show the expected change in a parameter estimate if it were freely estimated.} \n'
string_size = '\\scriptsize\n'

latex_miepc = table2Latex(df_miepc_theory_extra_load, dict_options, notes, string_size)
text_latex_miepc = open('Results/CFA_miepc_theory_extra_load.tex', 'w')
text_latex_miepc.write(latex_miepc)
text_latex_miepc.close()

### MI Covariances
dict_options = {'column_format': 'p{4.75cm}' + 'p{1cm}' * df_mi_cov_theory_extra.shape[1],
                'caption': ('Modification Indices of the Covariances: Two-factor Theory Model (Extra Covariances)'),
                'label': 'tab:cfa_mi_cov_theory_extra',
                'position': 'th'}
notes = '\\multicolumn{12}{p{20.5cm}}{\\textit{Notes.} Modification indices of the two-factor theory model with extra error covariances. The table only displays the modification indices for freeing error covariances. The modification indices relect a drop in the unscaled $\chi^2$ statistic after freeing a previously fixed parameter.} \n'
string_size = '\\scriptsize\n'

latex_miepc = table2Latex(df_mi_cov_theory_extra, dict_options, notes, string_size)
latex_miepc = latex_miepc.replace('table','sidewaystable')
text_latex_miepc = open('Results/CFA_mi_theory_extra_cov.tex', 'w')
text_latex_miepc.write(latex_miepc)
text_latex_miepc.close()

### EPC Covariances
dict_options = {'column_format': 'p{4.75cm}' + 'p{1cm}' * df_epc_cov_theory_extra.shape[1],
                'caption': ('EPCs of the Covariances: Two-factor Theory Model (Extra Covariances)'),
                'label': 'tab:cfa_epc_cov_theory_extra',
                'position': 'th'}
notes = '\\multicolumn{12}{p{20.5cm}}{\\textit{Notes.} Completely standardized expected parameter change (EPC) of the two-factor theory model with extra error covariances. The table only displays the EPCs for freeing error covariances. The EPCs show the expected change in a parameter estimate if it were freely estimated.} \n'
string_size = '\\scriptsize\n'

latex_miepc = table2Latex(df_epc_cov_theory_extra, dict_options, notes, string_size)
latex_miepc = latex_miepc.replace('table','sidewaystable')
text_latex_miepc = open('Results/CFA_epc_theory_extra_cov.tex', 'w')
text_latex_miepc.write(latex_miepc)
text_latex_miepc.close()

# Three-factor model
## Get tidy tables
df_miepc_3f_load, df_mi_cov_3f, df_epc_cov_3f = tidyModInd(df_mi_3f)

## To latex
### MI EPC loadings
dict_options = {'column_format': 'p{4.75cm}' + 'p{1.5cm}' * df_miepc_3f_load.shape[1],
                'caption': ('Modification Indices and EPCs of the Factor Loadings: Three-factor Theory Model'),
                'label': 'tab:cfa_mipec_load_3f',
                'position': 'th'}
notes = '\\multicolumn{7}{p{16cm}}{\\textit{Notes.} Modification indices and the completely standardized expected parameter change (EPC) of the three-factor model. The table only displays the modification indices and EPCs for freeing factor loadings. The proxies for \\textit{securitization income}, \\textit{servicing fees} and \\textit{credit default swaps purchased} do not have any modification indices and EPCs for factor loadings, because they already load on both factors. The modification indices relect a drop in the unscaled $\chi^2$ statistic after freeing a previously fixed parameter. The EPCs show the expected change in a parameter estimate if it were freely estimated.} \n'
string_size = '\\scriptsize\n'

latex_miepc = table2Latex(df_miepc_3f_load, dict_options, notes, string_size)
text_latex_miepc = open('Results/CFA_miepc_3f_load.tex', 'w')
text_latex_miepc.write(latex_miepc)
text_latex_miepc.close()

### MI Covariances
dict_options = {'column_format': 'p{4.75cm}' + 'p{1cm}' * df_mi_cov_3f.shape[1],
                'caption': ('Modification Indices of the Covariances: Three-factor Theory Model'),
                'label': 'tab:cfa_mi_cov_3f',
                'position': 'th'}
notes = '\\multicolumn{12}{p{20.5cm}}{\\textit{Notes.} Modification indices of the three-factor model. The table only displays the modification indices for freeing error covariances. The modification indices relect a drop in the unscaled $\chi^2$ statistic after freeing a previously fixed parameter.} \n'
string_size = '\\scriptsize\n'

latex_miepc = table2Latex(df_mi_cov_3f, dict_options, notes, string_size)
latex_miepc = latex_miepc.replace('table','sidewaystable')
text_latex_miepc = open('Results/CFA_mi_3f_cov.tex', 'w')
text_latex_miepc.write(latex_miepc)
text_latex_miepc.close()

### EPC Covariances
dict_options = {'column_format': 'p{4.75cm}' + 'p{1cm}' * df_epc_cov_3f.shape[1],
                'caption': ('EPCs of the Covariances: Three-factor Theory Model'),
                'label': 'tab:cfa_epc_cov_3f',
                'position': 'th'}
notes = '\\multicolumn{12}{p{20.5cm}}{\\textit{Notes.} Completely standardized expected parameter change (EPC) of the three-factor model. The table only displays the EPCs for freeing error covariances. The EPCs show the expected change in a parameter estimate if it were freely estimated.} \n'
string_size = '\\scriptsize\n'

latex_miepc = table2Latex(df_epc_cov_3f, dict_options, notes, string_size)
latex_miepc = latex_miepc.replace('table','sidewaystable')
text_latex_miepc = open('Results/CFA_epc_3f_cov.tex', 'w')
text_latex_miepc.write(latex_miepc)
text_latex_miepc.close()


# --------------------------------------------
# Communalities
# --------------------------------------------

# Theory model
## Clean the table
df_r2_theory_tidy = df_r2_theory.rename(columns={'x': 'Communality'}, index=dict_vars)

## Add unique variance column
df_r2_theory_tidy['Unique Variance'] = 1 - df_r2_theory_tidy.Communality

## Add column whether variable is new, used by or based on
#df_r2_theory_tidy['Source'] = ['Used by', 'Used by', 'From Call Reports', 'Used by', 'Based on',
#                               'Used by', 'From Call Reports', 'From Call Reports', 'Used by', 'Used by',
#                               'Based on', 'Based on']

## To latex
### Prelims
dict_options = {'column_format': 'p{5cm}' + 'p{1.5cm}' * df_r2_theory_tidy.shape[1],
                'caption': ('Communalities and Unique Variances: Two-factor Theory Model'),
                'label': 'tab:cfa_r2_theory',
                'position': 'th'}
notes = '\\multicolumn{3}{p{9cm}}{\\textit{Notes.} Communalities and unique variancess of the proxy variables.} \n'
string_size = '\\scriptsize\n'

### Get latex table and save
latex_r2_theory = table2Latex(df_r2_theory_tidy, dict_options, notes, string_size)
text_latex_r2_theory = open('Results/CFA_r2_theory.tex', 'w')
text_latex_r2_theory.write(latex_r2_theory)
text_latex_r2_theory.close()
